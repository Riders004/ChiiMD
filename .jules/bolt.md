## 2024-07-25 - Reduce Unnecessary Database Writes (Attempted)

**Learning:** An attempt was made to reduce unnecessary disk I/O by introducing a "dirty" flag to track changes to the in-memory database (`global.db.data`). However, the implementation proved to be critically unsafe. In a plugin-based architecture where dozens of plugins can directly mutate the global database object, it is nearly impossible to manually instrument every single mutation point. This creates a high risk of silent data loss, where a plugin could modify data that is never written to disk. The manual approach is too fragile and error-prone for this codebase.

**Action:** Reverted the attempted change. For this optimization to be implemented safely, a more robust, centralized mechanism is required. The ideal solution would be to wrap `global.db.data` in a `Proxy` object. The `Proxy` would intercept all write operations (sets, deletes) and automatically set the dirty flag, ensuring that *every* change is tracked without requiring manual intervention in every plugin. This would eliminate the risk of data loss and provide a reliable way to optimize database writes. Avoid manual dirty-flag tracking in the future.

## 2024-07-25 - Safe Throttling of Database Writes
**Learning:** In a Proxy-based architecture where the global database is directly mutated by many plugins, manual 'dirty' flag tracking is unsafe. However, the recursive Proxy implementation in main.js is very sensitive. Using Object.assign or replacing entire objects in the database triggers unnecessary 'set' traps, marking the database as dirty on every message even when no data changed.
**Action:** Optimize database initialization (lib/database.js) to perform in-place mutations/selective property updates. This ensures that the 'dirty' flag is only set when new properties are added or data actually changes, significantly reducing redundant disk I/O and serialization overhead.
